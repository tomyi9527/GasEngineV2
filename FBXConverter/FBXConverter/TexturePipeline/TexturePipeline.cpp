#include "stdafx.h"
#include "TexturePipeline.h"
#include "tga.h"
#include "png.h"

TexturePipeline::TexturePipeline()
{
}


TexturePipeline::~TexturePipeline()
{
}

void* TexturePipeline::loadTGA(const std::string& filePath, \
	unsigned short& width, unsigned short& height, unsigned char& depth, unsigned char& alpha)
{
	//this lib load tga data from low to top, this means the lowest bytes are lowest scanline of pic
	TGAData* data = (TGAData*)malloc(sizeof(TGAData));
	memset(data, 0, sizeof(TGAData));

	TGA* inputTGA = TGAOpen(const_cast<char*>(filePath.c_str()), "rb");
	if (!inputTGA)
		return NULL;

	data->flags = TGA_IMAGE_ID | TGA_IMAGE_DATA | TGA_RGB;
	TGAReadImage(inputTGA, data);

	if (inputTGA->last != TGA_OK)
	{
		//TGA_ERROR(inputTGA, inputTGA->last);
		return NULL;
	}	

	width = inputTGA->hdr.width;
	height = inputTGA->hdr.height;
	depth = inputTGA->hdr.depth;
	alpha = inputTGA->hdr.alpha;

	TGAClose(inputTGA);

	tbyte* imgData = data->img_data;
	if (data->cmap)
	{
		free(data->cmap);
	}

	if (data->img_id)
	{
		free(data->img_id);
	}

	free(data);

	return imgData;
}

bool TexturePipeline::writePNG(const std::string& filePath, unsigned short width, unsigned short height, \
	unsigned char depth, unsigned char alpha, unsigned char* data)
{
	png_structp png_ptr;
	png_infop info_ptr;

	const char* csFilePath = filePath.c_str();
	FILE* fp = fopen(csFilePath, "wb");
	if (fp == NULL)
		return false;

	png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);

	if (png_ptr == NULL)
	{
		fclose(fp);
		return false;
	}

	info_ptr = png_create_info_struct(png_ptr);
	if (info_ptr == NULL)
	{
		fclose(fp);
		png_destroy_write_struct(&png_ptr, NULL);
		return false;
	}

	if (setjmp(png_jmpbuf(png_ptr)))
	{
		fclose(fp);
		png_destroy_write_struct(&png_ptr, &info_ptr);
		return false;
	}

	png_init_io(png_ptr, fp);

	int bit_depth = 8;
	if (alpha > 0)
	{
		png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, PNG_COLOR_TYPE_RGB_ALPHA, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
	}
	else
	{
		png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
	}

	{
		png_text text_ptr[3];

		char key0[] = "Title";
		char text0[] = "Neonate Texture Pipeline";
		text_ptr[0].key = key0;
		text_ptr[0].text = text0;
		text_ptr[0].compression = PNG_TEXT_COMPRESSION_NONE;
		text_ptr[0].itxt_length = 0;
		text_ptr[0].lang = NULL;
		text_ptr[0].lang_key = NULL;

		char key1[] = "Author";
		char text1[] = "Tom Yi";
		text_ptr[1].key = key1;
		text_ptr[1].text = text1;
		text_ptr[1].compression = PNG_TEXT_COMPRESSION_NONE;
		text_ptr[1].itxt_length = 0;
		text_ptr[1].lang = NULL;
		text_ptr[1].lang_key = NULL;

		char key2[] = "Description";
		char text2[] = "This file is generated by the texture pipeline of Neonate 3D Graphics Engine";
		text_ptr[2].key = key2;
		text_ptr[2].text = text2;
		text_ptr[2].compression = PNG_TEXT_COMPRESSION_zTXt;
		text_ptr[2].itxt_length = 0;
		text_ptr[2].lang = NULL;
		text_ptr[2].lang_key = NULL;

		png_set_text(png_ptr, info_ptr, text_ptr, 3);
	}

	png_write_info(png_ptr, info_ptr);

	for (int i = 0; i < height; ++i)
	{
		png_write_row(png_ptr, (png_const_bytep)(&data[(height - 1 - i)*width*depth/8]));
	}

	png_write_end(png_ptr, info_ptr);

	png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
	png_destroy_write_struct(&png_ptr, &info_ptr);
	fclose(fp);

	return true;
}